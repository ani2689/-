### 굳이 도커를 사용하는 이유

여기 서버 A와 서버 B가 있다. 서버 A는 한달 전에 구성, 서버 B는 이제 막 구성했다면 이 두 서버가 운영체제, 컴파일러, 설치된 패키지까지 완벽히 똑같으리라는 가정이 없다.그리고 이와 같은 차이점에서 장애가 발생한다. 

A 서버가 잘되는데 B 서버는 안되거나, 그 반대일 수도 있다는 것이다.

이렇게 다른 서버들이 존재하는 것을 눈송이 서버라고도 한다. 결정체들이 각각 모양이 다르듯 서버들도 각각 다른 모습이라는 것을 뜻한다.

예를 들어 X라는 도구를 설치헀다고 해보자. A 서버는 한달 전의 X를, B 서버는 최신의 X를 사용한다. 이때 두 서버를 실행하자 A 서버에서 장애가 터졌다면. 몇가지의 문제가 짐작된다.

-  웹 서비스에서 X의 최신버전에 있는 기능을 사용했다.
-  웹 서비스 업데이트 부분에 버그가 있다.
-  X의 버전이 다르다.
-  X가 의존하는 라이브러리의 버전이 다르다.

그러나 A 서버를 구성한 개발자가 옆에 없다면 B 서버를 구성한 사람이 A 서버가 구성되고 운영된 모든 관점을 파악하려고 할 것이다. 그래야 B 서버와의 차이점을 알 수 있으니까.

### 서버를 코드로 구성하고 관리하는 방법

위의 상황을 개선하고자 다양한 방법으로 서버 운영 기록을 저장해두곤 한다.
- 사내 문서 도구에 기록,  tmux-xpanes와 같은 도구를 사용

하지만 문서에 적힌대로 해봐도 제대로 작동되지 않거나 여러 서버를 조작할 때 하나의 서버만 장애가 터지곤 한다.

따라서 서버의 운영기록을 코드화 하려는 다양한 시도들이 등장한다.
- 베이그런트`Vagrant`나 셰프`Chef`, 퍼핏 `Puppet`, 앤서블 `Ansible` 등

그리고 이 속에는 도커도 포함된다. 도커 파일은 서버 운영기록을 코드화 한 것. 도커 파일로는 도커 이미지를 만든다. 도커 파일이 서버 운영 기록이라면 도커 이미지는 운영 기록을 실행할 시점이라고 할 수 있다.

C 서버를 1년 전에 구성하고, D 서버를 이제 막 구성했다. 두 서버에는 X라는 도구가 설치되어 있다고 하면 그 간격은 1년차다. 그러나 도커 이미지를 사용하면 서버가 구성되는 시점이 이미지를 만든 시점으로 구성되어 언제 실행하던 그 이미지를 만든 시점으로 고정되게 된다. 이미지를 사용해 1년전에 C 서버를 배포, 이제 막 D 서버를 배포하게 된대도 두 컨테이너 모두 X가 설치된 시점이 같은 것이다.

다른 서버빌드 도구가 실행되는 시점에 서버의 상태가 결정된다면, 도커는 이미지를 만든 시점에 서버의 상태가 결정되기 때문에 서버를 항상 똑같은 상태로 만들 수 있게 된다.

### 테스트 주도 개발의 관점에서 도커 파일 바라보기

소프트웨어 작성에 도움을 주는 기법중 하나인 테스트 주도 개발.
1. 테스트를 작성
2. 테스트에 실패
3. 코드를 작성/수정
4. 테스트 성공
5. 중복되거나 불필요한 코드들을 리팩토링
6. 테스트 성공 여부에 따라 1번으로 돌아가기

도커 파일 역시 이런 관점으로 바라볼 수 있다.
1. 도커 파일을 작성
2. 도커 이미지 빌드 실패
3. 도커 파일 작성/수정
4. 이미지 빌드 성공
5. 도커 파일 효율화
6. 이미지 빌드 성공 여부에 따라 1번으로 돌아가기

### 클래스과 인스턴트처럼 도커 이미지 바라보기

도커 이미지로는 항상 같은 형태의 서버를 실행할 수 있다. 그러나 도커 파일을 전혀 만지지 않은 상태에서 내일 다시 도커 이미지를 빌드한다면 두 이미지가 완전히 같다고 할 수 있을까?

두 이미지는 서로 달라질 수 있다. 단 하루 간격으로 X라는 도구가 업데이트 되었을 수도, 타 패키지가 보안 이슈로 패치되었을 수도 있기 때문이다.

지금까지는 서버를 똑같이 만드는데에 신경썼지만 달라야 할 것도 있다. 한 컴퓨터에서 E 라는 도커 컨테이너를 두 개 배포했다면 이 둘을 어떻게 구분해야 할까? 

도커에서는 내부 규칙에 따라 해시값 (컨테이너 고유의 id)과 고유의 이름(컨테이너 이름)을 붙이며 각각의 IP도 다르다. 도커에서는 바뀌어야 할 부분과 바뀌지 않아야 할 부분을 나누며, 바뀌는 부분을 환경변수로 처리한다.

이렇게 도커 컨테이너는 도커 이미지에 실행 시점에 수정되어야 할 정보들을 더한 것이라고 할 수 있다.

마치 public과 private 처럼, 서버에서 숨길 부분은 숨기고 드러낼 부분은 드러낸 덕분에 견고함과 유연성을 모두 얻은 것이다. 컨테이너 기술 덕분에 서버를 설치하고 운영기록을 별도로 관리하는 고단함 없이 잘 만들어진 서버를 사용할 수 있다. 자신이 만든 서버가 아니더라도.

클래스에서 인스턴스가 끝없이 나올 수 있는 것처럼, 한 도커 이미지에서 생성할 수 있는 컨테이너 갯수는 제한이 없다.

### 정리

서버를 코드화하면 
- 서버 제작 과정에 견고함과 유연성을 더해준다.
- 다른 이가 만든 서버를 프로그램 다운하듯 사용할 수 있다.
- 여러 대에 마음껏 배포할 수 있다.
  
굳이 도커를 사용하는 이유
- 도커 없이도 배포하고, 운영하고 있는데 아무 불편함이 없다?
- 문제라고 느끼지 않는 문제는 없는지, 수평적 확장이 자유로운지, 서버의 견고함을 유지하면서 동적으로 바꿀 수 있는 유연함이 존재하는지, 프로젝트를 인수인계 할 때 시간이 얼마나 오래 걸리는지, 이 모든 물음에 답할 수 있는지!
- 도커가 아니어도 이미 다른 방식으로 문제를 해결할 수 있겠지만 지금으로썬 도커가 가장 최선의 방법이라는 것.
  

  ---

  ##### ✨ 참고글 [왜 굳이 도커(컨테이너)를 써야 하나요?](https://www.44bits.io/ko/post/why-should-i-use-docker-container)